'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { db } from '../firebase';
import {
  collection,
  query,
  where,
  orderBy,
  getDocs,
  doc,
  getDoc,
  updateDoc,
  deleteDoc,
  addDoc,
  serverTimestamp,
  arrayUnion,
  arrayRemove,
} from 'firebase/firestore';
import type { Album } from '@myphoto/shared';
import { useAuthStore } from '../stores';

// Helper to convert Firestore document to Album
function docToAlbum(doc: any): Album {
  const data = doc.data();
  return {
    id: doc.id,
    ...data,
    createdAt: data.createdAt?.toDate() || new Date(),
    updatedAt: data.updatedAt?.toDate() || new Date(),
  } as Album;
}

export function useAlbums() {
  const user = useAuthStore((state) => state.user);

  return useQuery({
    queryKey: ['albums', user?.id],
    queryFn: async () => {
      if (!user) throw new Error('Not authenticated');

      const q = query(
        collection(db, 'albums'),
        where('userId', '==', user.id),
        orderBy('createdAt', 'desc')
      );

      const snapshot = await getDocs(q);
      return snapshot.docs.map(docToAlbum);
    },
    enabled: !!user,
  });
}

export function useAlbum(albumId: string) {
  return useQuery({
    queryKey: ['album', albumId],
    queryFn: async () => {
      const docRef = doc(db, 'albums', albumId);
      const docSnap = await getDoc(docRef);

      if (!docSnap.exists()) {
        throw new Error('Album not found');
      }

      return docToAlbum(docSnap);
    },
    enabled: !!albumId,
  });
}

export function useCreateAlbum() {
  const queryClient = useQueryClient();
  const user = useAuthStore((state) => state.user);

  return useMutation({
    mutationFn: async ({ name, description }: { name: string; description?: string }) => {
      if (!user) throw new Error('Not authenticated');

      const albumData: Omit<Album, 'id' | 'createdAt' | 'updatedAt'> = {
        userId: user.id,
        name,
        description,
        isAutoGenerated: false,
        isShared: false,
        sharedWith: [],
        fileCount: 0,
      };

      const docRef = await addDoc(collection(db, 'albums'), {
        ...albumData,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });

      return {
        id: docRef.id,
        ...albumData,
        createdAt: new Date(),
        updatedAt: new Date(),
      } as Album;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['albums'] });
    },
  });
}

export function useUpdateAlbum() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      albumId,
      updates,
    }: {
      albumId: string;
      updates: Partial<Pick<Album, 'name' | 'description' | 'coverFileId'>>;
    }) => {
      const docRef = doc(db, 'albums', albumId);
      await updateDoc(docRef, {
        ...updates,
        updatedAt: serverTimestamp(),
      });
    },
    onSuccess: (_, { albumId }) => {
      queryClient.invalidateQueries({ queryKey: ['albums'] });
      queryClient.invalidateQueries({ queryKey: ['album', albumId] });
    },
  });
}

export function useDeleteAlbum() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (albumId: string) => {
      // First, remove album from all files that contain it
      const filesQuery = query(
        collection(db, 'files'),
        where('albumIds', 'array-contains', albumId)
      );
      const filesSnapshot = await getDocs(filesQuery);

      const updatePromises = filesSnapshot.docs.map((fileDoc) =>
        updateDoc(doc(db, 'files', fileDoc.id), {
          albumIds: arrayRemove(albumId),
          updatedAt: serverTimestamp(),
        })
      );
      await Promise.all(updatePromises);

      // Then delete the album
      const docRef = doc(db, 'albums', albumId);
      await deleteDoc(docRef);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['albums'] });
      queryClient.invalidateQueries({ queryKey: ['files'] });
    },
  });
}

export function useAddFilesToAlbum() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ albumId, fileIds }: { albumId: string; fileIds: string[] }) => {
      // Update each file to include the album
      const updatePromises = fileIds.map((fileId) =>
        updateDoc(doc(db, 'files', fileId), {
          albumIds: arrayUnion(albumId),
          updatedAt: serverTimestamp(),
        })
      );
      await Promise.all(updatePromises);

      // Update album file count
      const albumRef = doc(db, 'albums', albumId);
      const albumSnap = await getDoc(albumRef);
      if (albumSnap.exists()) {
        const currentCount = albumSnap.data().fileCount || 0;
        await updateDoc(albumRef, {
          fileCount: currentCount + fileIds.length,
          updatedAt: serverTimestamp(),
        });
      }
    },
    onSuccess: (_, { albumId }) => {
      queryClient.invalidateQueries({ queryKey: ['albums'] });
      queryClient.invalidateQueries({ queryKey: ['album', albumId] });
      queryClient.invalidateQueries({ queryKey: ['files'] });
    },
  });
}

export function useRemoveFilesFromAlbum() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ albumId, fileIds }: { albumId: string; fileIds: string[] }) => {
      // Update each file to remove the album
      const updatePromises = fileIds.map((fileId) =>
        updateDoc(doc(db, 'files', fileId), {
          albumIds: arrayRemove(albumId),
          updatedAt: serverTimestamp(),
        })
      );
      await Promise.all(updatePromises);

      // Update album file count
      const albumRef = doc(db, 'albums', albumId);
      const albumSnap = await getDoc(albumRef);
      if (albumSnap.exists()) {
        const currentCount = albumSnap.data().fileCount || 0;
        await updateDoc(albumRef, {
          fileCount: Math.max(0, currentCount - fileIds.length),
          updatedAt: serverTimestamp(),
        });
      }
    },
    onSuccess: (_, { albumId }) => {
      queryClient.invalidateQueries({ queryKey: ['albums'] });
      queryClient.invalidateQueries({ queryKey: ['album', albumId] });
      queryClient.invalidateQueries({ queryKey: ['files'] });
    },
  });
}


export function useUnshareAlbum() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (albumId: string) => {
      const docRef = doc(db, 'albums', albumId);
      await updateDoc(docRef, {
        isShared: false,
        shareLink: null,
        sharedWith: [],
        updatedAt: serverTimestamp(),
      });
    },
    onSuccess: (_, albumId) => {
      queryClient.invalidateQueries({ queryKey: ['albums'] });
      queryClient.invalidateQueries({ queryKey: ['album', albumId] });
    },
  });
}
